---
description: Testing — coverage expectations, unit/integration, no LLM in tests, branch coverage, unittestable code
globs: "**/*.test.ts,**/*.spec.ts,packages/ui/**/*.ts,packages/runtime/**/*.ts"
alwaysApply: false
---

# Testing strategy

- **Critical business logic:** ~90–100% unit test coverage. Non-critical: reasonable coverage. Infrastructure/trivial: optional if tested elsewhere. Gaps must be acknowledged and justified.
- **Coverage gaps:** Add tests to cover missing code; do not exclude code from coverage to meet targets (see `coverage-and-test-failures` rule).
- **All branches:** Aim for 100% branch coverage. Add tests for every branch (conditionals, switch cases, error paths). Use `npm run test:coverage` and the HTML report to find and close gaps. Do not lower the branch threshold.
- **Unittestable / hard-to-test code:** Test at the nearest testable boundary (integration or e2e). Document why a file or branch is not unit-tested and how it is covered (e.g. e2e, manual). See `docs/testing-and-coverage.md`.
- **Focus on branches, edge cases, failure modes.** Avoid testing implementation details; avoid brittle tests.
- **Use code fallbacks consciously.** Fallback paths (default values, alternate logic on failure) add branches and edge cases and make tests more complex. When adding a fallback, do it intentionally—aware of the extra branches to test and maintain—not by habit or “just in case.”
- **Run coverage:** From repo root `npm run test:coverage`; HTML report in `packages/ui/coverage/index.html`.
- **No LLM in tests** for code paths, data flow, tool execution. Use deterministic mocks (fixed `priorityOrder`/`refinedTask`, mock `runSpecialist`/LLM, fixture responses). Heap/chat/improvement tests: mock `get_run_for_improvement` and LLM; assert flow and DB, not model quality.
- **Unit tests default;** integration tests only for multi-component/external boundaries. When fixing a bug, add a test that would have failed before the fix (see `bug-fix-add-tests` rule).
- **Definition of done:** Core logic unit-tested; branches and edge cases covered; unittestable code documented and tested at boundary where feasible. Before finalizing: run tests, run coverage, run build, run `npm run pre-push` before pushing.
